"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenerateCommand = void 0;
const axios_1 = __importDefault(require("axios"));
const ApiExecutor_1 = require("../api/ApiExecutor");
const parseGithubIssue_1 = require("../parser/parseGithubIssue");
const parseJiraIssue_1 = require("../parser/parseJiraIssue");
const parseLabels_1 = require("../parser/parseLabels");
const DiffVersionService_1 = require("../service/DiffVersionService");
class GenerateCommand {
    constructor() {
        this.command = "generate";
        this.deprecated = false;
        this.describe = "Generate the release note";
    }
    builder(args) {
        return args
            .options("c", {
            alias: "config",
            demandOption: false,
            describe: "config name ex: ioe (config/ioe.json)"
        })
            .options("r", {
            alias: "repo",
            demandOption: false,
            describe: "Github <OWNER>/<REPOSITORY>"
        })
            .options("l", {
            alias: "label",
            demandOption: false,
            describe: "Github PR label (for multi packages), Ex: foo-1,foo-2"
        })
            .options("s", {
            alias: "start",
            demandOption: false,
            describe: "Start compare tag"
        })
            .options("e", {
            alias: "end",
            demandOption: false,
            describe: "End compare tag",
        })
            .options("t", {
            alias: "token",
            demandOption: false,
            describe: "Github api token"
        })
            .options("j", {
            alias: "jira",
            demandOption: false,
            describe: "JIRA base url"
        })
            .options("o", {
            alias: "project",
            demandOption: false,
            describe: "JIRA project"
        })
            .options("u", {
            alias: "username",
            demandOption: false,
            describe: "JIRA username"
        })
            .options("p", {
            alias: "password",
            demandOption: false,
            describe: "JIRA password"
        })
            .options("n", {
            alias: "noUpdate",
            demandOption: false,
            describe: "No update Github release note"
        })
            .options("a", {
            alias: "packagePath",
            default: "package.json",
            demandOption: false,
            describe: "Package.json path"
        })
            .options("dp", {
            alias: "deepPackages",
            demandOption: false,
            describe: "packages refer issue. Ex: foo1,foo2"
        })
            .options("dr", {
            alias: "deepRepos",
            demandOption: false,
            describe: "deep packages repos"
        })
            .options("dl", {
            alias: "deepLabels",
            demandOption: false,
            describe: "deep packages commit filter by label"
        })
            .options("dx", {
            alias: "deepPrefix",
            demandOption: false,
            describe: "tag prefix for each dependencies module"
        });
    }
    async handler(args) {
        if (args.config) {
            process.env["NODE_CONFIG_ENV"] = args.config;
            const config = require("config");
            args = Object.assign(Object.assign({}, args), config);
        }
        const apiExecutor = new ApiExecutor_1.ApiExecutor({ repo: args.repo, token: args.token });
        const compares = await apiExecutor.compare(args.start, args.end);
        const compareCommits = compares.commits;
        let packagesCommits = [];
        let diffVersions = [];
        if (args.deepPackages && args.deepRepos && args.deepLabels) {
            const diffVersionService = new DiffVersionService_1.DiffVersionService(apiExecutor);
            diffVersions = diffVersionService.getVersions(compares, args.packagePath, args.deepPackages.split(","), args.deepRepos.split(","), args.deepLabels.split(","), args.deepPrefix.split(","));
            packagesCommits = await diffVersionService.getPackagesCommits(diffVersions);
        }
        const labels = args.label ? args.label.split(",").map((label) => label.trim()) : [];
        let releaseNote = "";
        const commits = args.label ?
            compareCommits.filter((it) => {
                const commitLabels = parseLabels_1.parseLabels(it.commit.message);
                return labels.some((label) => commitLabels.includes(label));
            }) :
            compareCommits;
        let jiraIssues = commits
            .concat(packagesCommits)
            .reduce((memo, it) => {
            return memo.concat(parseJiraIssue_1.parseJiraIssue(it.commit.message));
        }, [])
            .reduce((memo, it) => {
            if (it && !memo.includes(it.toUpperCase())) {
                memo.push(it.toUpperCase());
            }
            return memo;
        }, []);
        if (args.project) {
            const projects = args.project.split(",");
            jiraIssues = jiraIssues.filter((it) => it && projects.some((project) => it.startsWith(project.toUpperCase())));
        }
        const jiraLines = await Promise.all(jiraIssues.map((jiraIssue) => {
            return new Promise((resolve) => {
                axios_1.default.get(`${args.jira}/rest/api/latest/issue/${jiraIssue}`, {
                    auth: { username: args.username, password: args.password }
                }).then((res) => {
                    resolve(`- [${jiraIssue}](${args.jira}/browse/${jiraIssue}) ${res.data.fields.summary}`);
                }).catch(() => {
                    resolve(`- ${jiraIssue} not found issue summary`);
                });
            });
        }));
        releaseNote += `### JIRA issue\n${jiraLines.join('\n')}\n\n`;
        if (diffVersions.length > 0) {
            releaseNote += "### Dependencies upgrade\n";
            diffVersions.map((it) => {
                releaseNote += `- ${it.packageName} ${it.from} -> ${it.to}\n`;
            });
            releaseNote += "\n\n";
        }
        const githubIssues = commits
            .reduce((memo, it) => {
            return memo.concat(parseGithubIssue_1.parseGithubIssue(it.commit.message));
        }, [])
            .filter((it) => !!it)
            .map((it) => it.replace("#", ""))
            .reduce((memo, it) => {
            if (!memo.includes(it)) {
                memo.push(it);
            }
            return memo;
        }, []);
        const lines = await Promise.all(githubIssues.map((githubIssue) => {
            return new Promise((resolve) => {
                axios_1.default.get(`https://api.github.com/repos/${args.repo}/issues/${githubIssue}`, {
                    headers: { Authorization: `token ${args.token}` }
                }).then((res) => {
                    resolve(!res.data.pull_request ? `- #${githubIssue} ${res.data.title}` : "");
                });
            });
        }));
        releaseNote += `### Github issue\n${lines.filter((line) => line !== "").join('\n')}`;
        if (!args.noUpdate) {
            const releaseRes = await axios_1.default
                .get(`https://api.github.com/repos/${args.repo}/releases/tags/${args.end}`, {
                headers: {
                    Authorization: `token ${args.token}`
                }
            });
            await axios_1.default
                .patch(`https://api.github.com/repos/${args.repo}/releases/${releaseRes.data.id}`, {
                body: releaseNote
            }, { headers: { Authorization: `token ${args.token}` } });
        }
        console.log(`# ${args.end} RELEASE NOTE\n`, releaseNote);
    }
}
exports.GenerateCommand = GenerateCommand;
//# sourceMappingURL=GenerateCommand.js.map