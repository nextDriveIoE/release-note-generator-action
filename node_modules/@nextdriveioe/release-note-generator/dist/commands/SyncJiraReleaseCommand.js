"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncJiraReleaseCommand = void 0;
const core_1 = require("@octokit/core");
const axios_1 = __importDefault(require("axios"));
const date_fns_1 = require("date-fns");
const parseJiraIssue_1 = require("../parser/parseJiraIssue");
class SyncJiraReleaseCommand {
    constructor() {
        this.command = "sync:jira";
        this.deprecated = false;
        this.describe = "sync jira release version";
    }
    builder(args) {
        return args
            .options("r", {
            alias: "repo",
            demandOption: true,
            describe: "Github <OWNER>/<REPOSITORY>"
        })
            .options("t", {
            alias: "token",
            demandOption: true,
            describe: "Github api token"
        })
            .options("a", {
            alias: "tag",
            demandOption: true,
            describe: "Github release tag"
        })
            .options("j", {
            alias: "jira",
            demandOption: true,
            describe: "JIRA base url"
        })
            .options("o", {
            alias: "project",
            demandOption: true,
            describe: "JIRA project ID"
        })
            .options("u", {
            alias: "username",
            demandOption: false,
            describe: "JIRA user email"
        })
            .options("p", {
            alias: "password",
            demandOption: true,
            describe: "JIRA personal token"
        });
    }
    async handler(args) {
        const jiraOptions = {
            auth: { username: args.username, password: args.password }
        };
        const octokit = new core_1.Octokit({
            auth: args.token
        });
        const [owner, repo] = args.repo.split("/");
        const jiraVersion = `${repo} ${args.tag}`;
        const release = await octokit.request("GET /repos/{owner}/{repo}/releases/tags/{tag}", {
            owner,
            repo,
            tag: args.tag
        });
        const res = await axios_1.default.get(`${args.jira}/rest/api/2/project/${args.project}/versions`, jiraOptions);
        const versionDto = res.data.find((it) => it.name === jiraVersion);
        let versionId = versionDto ? versionDto.id : null;
        if (!versionId) {
            const createRes = await axios_1.default.post(`${args.jira}/rest/api/2/version`, {
                "description": "From auto release system",
                "name": `${repo} ${args.tag}`,
                "archived": false,
                "released": false,
                "releaseDate": date_fns_1.format(new Date(), "yyyy-MM-dd"),
                "projectId": Number(args.project)
            }, jiraOptions);
            versionId = createRes.data.id;
        }
        const jiraIssues = parseJiraIssue_1.parseJiraIssueByNoSymbol(release.data.body);
        const jiraIssuePromises = jiraIssues.map((issue) => {
            new Promise((resolve) => {
                axios_1.default.get(`${args.jira}/rest/api/2/issue/${issue}`, jiraOptions).then((issueResponse) => {
                    const fixVersions = issueResponse.data.fields.fixVersions || [];
                    const fixVersionIds = fixVersions.map((it) => it.id);
                    if (fixVersionIds.includes(versionId)) {
                        resolve(true);
                    }
                    else {
                        axios_1.default.put(`${args.jira}/rest/api/2/issue/${issue}`, {
                            fields: {
                                fixVersions: fixVersionIds.concat(versionId).map((id) => ({ id }))
                            }
                        }, jiraOptions).then(() => resolve(true));
                    }
                });
            });
        });
        await Promise.all(jiraIssuePromises);
        console.log(`apply issues to ${jiraVersion}: ${jiraIssues.join(", ")}`);
    }
}
exports.SyncJiraReleaseCommand = SyncJiraReleaseCommand;
//# sourceMappingURL=SyncJiraReleaseCommand.js.map