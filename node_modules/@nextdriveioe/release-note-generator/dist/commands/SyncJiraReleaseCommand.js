"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateStatus = exports.getStatusTransitionId = exports.SyncJiraReleaseCommand = void 0;
const core_1 = require("@octokit/core");
const axios_1 = __importDefault(require("axios"));
const date_fns_1 = require("date-fns");
const lodash_1 = __importDefault(require("lodash"));
const parseJiraIssue_1 = require("../parser/parseJiraIssue");
const JiraStatus = {
    waitingForVerification: "Waiting for verification",
    closed: "Closed",
    resolved: "Resolved",
    deferred: "Deferred",
    monitoring: "Monitoring"
};
const JiraDoneStatuses = [
    JiraStatus.closed,
    JiraStatus.resolved,
    JiraStatus.deferred,
    JiraStatus.monitoring
];
class SyncJiraReleaseCommand {
    constructor() {
        this.command = "sync:jira";
        this.deprecated = false;
        this.describe = "sync jira release version";
    }
    builder(args) {
        return args
            .options("r", {
            alias: "repo",
            demandOption: true,
            describe: "Github <OWNER>/<REPOSITORY>"
        })
            .options("t", {
            alias: "token",
            demandOption: true,
            describe: "Github api token"
        })
            .options("a", {
            alias: "tag",
            demandOption: true,
            describe: "Github release tag"
        })
            .options("j", {
            alias: "jira",
            demandOption: true,
            describe: "JIRA base url"
        })
            .options("u", {
            alias: "username",
            demandOption: false,
            describe: "JIRA user email"
        })
            .options("p", {
            alias: "password",
            demandOption: true,
            describe: "JIRA personal token"
        });
    }
    async handler(args) {
        this.args = args;
        this.jiraOptions = {
            auth: { username: args.username, password: args.password }
        };
        const octokit = new core_1.Octokit({
            auth: args.token
        });
        const [owner, repo] = args.repo.split("/");
        const jiraVersion = `${repo} ${args.tag}`;
        const release = await octokit.request("GET /repos/{owner}/{repo}/releases/tags/{tag}", {
            owner,
            repo,
            tag: args.tag
        });
        const jiraIssues = parseJiraIssue_1.parseJiraIssueByNoSymbol(release.data.body);
        const groups = lodash_1.default(jiraIssues).groupBy((issue) => issue.split("-")[0]);
        const projectsPromise = groups.map((issues, projectKey) => new Promise(async (resolve) => {
            const jiraVersion = `${repo} ${args.tag}`;
            const versionId = await findVersionId(this.args, this.jiraOptions, projectKey, jiraVersion);
            await syncRelease(this.args, this.jiraOptions, versionId, issues);
            resolve(true);
        })).toArray();
        await Promise.all(projectsPromise);
        console.log(`apply issues to ${jiraVersion}: ${jiraIssues.join(", ")}`);
    }
}
exports.SyncJiraReleaseCommand = SyncJiraReleaseCommand;
async function findVersionId(args, jiraOptions, projectKey, jiraVersion) {
    const repo = args.repo.split("/")[1];
    const projectRes = await axios_1.default.get(`${args.jira}/rest/api/3/project/${projectKey}`, jiraOptions);
    const projectId = projectRes.data.id;
    const res = await axios_1.default.get(`${args.jira}/rest/api/2/project/${projectId}/versions`, jiraOptions);
    const versionDto = res.data.find((it) => it.name === jiraVersion);
    let versionId = versionDto ? versionDto.id : null;
    if (!versionId) {
        const createRes = await axios_1.default.post(`${args.jira}/rest/api/2/version`, {
            "description": "From auto release system",
            "name": `${repo} ${args.tag}`,
            "archived": false,
            "released": false,
            "releaseDate": date_fns_1.format(new Date(), "yyyy-MM-dd"),
            "projectId": Number(projectId)
        }, jiraOptions);
        return createRes.data.id;
    }
    else {
        return versionId;
    }
}
async function syncRelease(args, jiraOptions, versionId, jiraIssues) {
    const jiraIssuePromises = jiraIssues.map((issue) => new Promise((resolve) => {
        axios_1.default.get(`${args.jira}/rest/api/2/issue/${issue}`, jiraOptions).then((issueResponse) => {
            const currentJiraStatus = issueResponse.data.fields.status.name;
            const fixVersions = issueResponse.data.fields.fixVersions || [];
            const fixVersionIds = fixVersions.map((it) => it.id);
            if (fixVersionIds.includes(versionId)) {
                console.log(`fixVersion exists, id: "${versionId}"m should return immediately`);
                resolve(true);
                return;
            }
            axios_1.default.put(`${args.jira}/rest/api/2/issue/${issue}`, {
                fields: {
                    fixVersions: fixVersionIds.concat(versionId).map((id) => ({ id }))
                }
            }, jiraOptions).then(() => {
                if (JiraDoneStatuses.includes(currentJiraStatus)) {
                    console.log(`current Jira status is ${currentJiraStatus}, cannot transit to ${JiraStatus.waitingForVerification}`);
                    resolve(true);
                    return;
                }
                console.log(`update Jira status to "${JiraStatus.waitingForVerification}"`);
                updateStatus(args.jira, jiraOptions, issue, JiraStatus.waitingForVerification)
                    .then(() => resolve(true));
            });
        });
    }));
    await Promise.all(jiraIssuePromises);
}
async function getStatusTransitionId(baseUrl, jiraOptions, issue, statusName) {
    const jiraIssueTransitions = await axios_1.default.get(`${baseUrl}/rest/api/2/issue/${issue}/transitions`, jiraOptions);
    const jiraIssueTransition = jiraIssueTransitions.data.transitions.find((it) => it.to.name.toUpperCase() === statusName.toUpperCase());
    if (jiraIssueTransition) {
        return jiraIssueTransition.id;
    }
    return null;
}
exports.getStatusTransitionId = getStatusTransitionId;
async function updateStatus(baseUrl, jiraOptions, issue, statusName) {
    const id = await getStatusTransitionId(baseUrl, jiraOptions, issue, statusName);
    if (id) {
        try {
            await axios_1.default.post(`${baseUrl}/rest/api/2/issue/${issue}/transitions`, { transition: { id } }, jiraOptions);
        }
        catch (e) {
            console.warn(`issue ${issue} change status fail`);
        }
    }
}
exports.updateStatus = updateStatus;
//# sourceMappingURL=SyncJiraReleaseCommand.js.map