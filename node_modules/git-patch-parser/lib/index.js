/**
 * Parse a string that represents a git patch
 * @param  {String} contents The contents of the patch to parse
 * @return {Object}          An object where the keys are filenames, and the
 * values are the contents of the diff
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePatch = parsePatch;
exports.parseMultiPatch = parseMultiPatch;
exports.parseUnifiedDiff = parseUnifiedDiff;

function parsePatch(contents) {
  var sha = contents.split(" ")[1];

  var message = /^Subject: \[.+?\] ([\S\s]+)?^---$/m.exec(contents)[1].trim().replace("\n", "");

  var fileParts = contents.split(/^diff --git /m).slice(1);
  var files = {};

  fileParts.forEach(function (part) {
    var start = part.indexOf("@@");
    var diffContents = part.slice(start);

    // XXX won't work with spaces in filenames
    var fileNameMatch = /^\+\+\+ b\/(.+)$/m.exec(part);

    if (!fileNameMatch) {
      // This was probably a deleted file
      return;
    }

    var fileName = fileNameMatch[1];

    var fileData = parseUnifiedDiff(diffContents);

    files[fileName] = fileData;
  });

  return {
    files: files,
    sha: sha,
    message: message
  };
}

function parseMultiPatch(contents) {
  var patchStart = /^From /gm;

  var match = null;
  var patchIndices = [];
  while ((match = patchStart.exec(contents)) != null) {
    patchIndices.push(match.index);
  }

  var patches = [];
  patchIndices.forEach(function (_, i) {
    var patchContent = "";

    if (i + 1 < patchIndices.length) {
      patchContent = contents.slice(patchIndices[i], patchIndices[i + 1]);
    } else {
      patchContent = contents.slice(patchIndices[i]);
    }

    // Remove the weird -- 2.2.1 part at the end of every patch
    patchContent = patchContent.split(/^-- $/m)[0];
    patches.push(patchContent);
  });

  return patches.map(parsePatch);
}

function parseUnifiedDiff(diffContents) {
  var diffLines = diffContents.split("\n");
  var lineNumbers = diffLines[0];

  // Take off the last line which is just empty
  var contentPatchLines = diffLines.slice(0, diffLines.length - 1);

  var parsedLines = contentPatchLines.map(function (line) {
    // If the line starts with a backslash, it's not part of the patch. In
    // particular, this is the case with the "no newline at end of file" thing
    if (!line || /^\\/.test(line)) {
      // The last line ends up being an empty string
      return null;
    }

    if (/^@/.test(line)) {
      type = "lineNumbers";

      var lineNumberMatch = /^@@ -(\d+),?(\d+)? \+(\d+),?(\d+)? @@/.exec(line).map(function (str) {
        return parseInt(str, 10);
      });

      return {
        type: type,
        lineNumbers: {
          removed: {
            start: lineNumberMatch[1],
            lines: lineNumberMatch[2]
          },
          added: {
            start: lineNumberMatch[3],
            lines: lineNumberMatch[4]
          }
        }
      };
    }

    var type = "context";
    if (/^\+/.test(line)) {
      type = "added";
    } else if (/^-/.test(line)) {
      type = "removed";
    }

    var content = line.slice(1);

    return {
      type: type,
      content: content
    };
  });

  // Now that we have parsed all of the lines, assemble them into sections that
  // have their own line number ranges
  var sections = [];
  var currSection = undefined;

  parsedLines.forEach(function (line) {
    if (line !== null) {
      if (line.type == "lineNumbers") {
        if (currSection) {
          sections.push(currSection);
        }

        currSection = {
          lines: [],
          lineNumbers: line.lineNumbers
        };
      } else {
        currSection.lines.push(line);
      }
    }
  });

  sections.push(currSection);

  return sections;
}